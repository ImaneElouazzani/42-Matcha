{"ast":null,"code":"import { useContext, useState, useCallback, createElement, useMemo } from 'react';\nimport { useForceUpdate } from '@reach/utils/use-force-update';\nimport { useIsomorphicLayoutEffect } from '@reach/utils/use-isomorphic-layout-effect';\nimport { usePrevious } from '@reach/utils/use-previous';\nimport { createNamedContext } from '@reach/utils/context';\nimport { noop } from '@reach/utils/noop';\n\nfunction _objectWithoutPropertiesLoose(source, excluded) {\n  if (source == null) return {};\n  var target = {};\n  var sourceKeys = Object.keys(source);\n  var key, i;\n\n  for (i = 0; i < sourceKeys.length; i++) {\n    key = sourceKeys[i];\n    if (excluded.indexOf(key) >= 0) continue;\n    target[key] = source[key];\n  }\n\n  return target;\n}\n\nfunction _extends() {\n  _extends = Object.assign || function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n\n    return target;\n  };\n\n  return _extends.apply(this, arguments);\n}\n\nfunction createDescendantContext(name, initialValue) {\n  if (initialValue === void 0) {\n    initialValue = {};\n  }\n\n  var descendants = [];\n  return createNamedContext(name, _extends({\n    descendants: descendants,\n    registerDescendant: noop,\n    unregisterDescendant: noop\n  }, initialValue));\n}\n/**\n * This hook registers our descendant by passing it into an array. We can then\n * search that array by to find its index when registering it in the component.\n * We use this for focus management, keyboard navigation, and typeahead\n * functionality for some components.\n *\n * The hook accepts the element node and (optionally) a key. The key is useful\n * if multiple descendants have identical text values and we need to\n * differentiate siblings for some reason.\n *\n * Our main goals with this are:\n *   1) maximum composability,\n *   2) minimal API friction\n *   3) SSR compatibility*\n *   4) concurrent safe\n *   5) index always up-to-date with the tree despite changes\n *   6) works with memoization of any component in the tree (hopefully)\n *\n * * As for SSR, the good news is that we don't actually need the index on the\n * server for most use-cases, as we are only using it to determine the order of\n * composed descendants for keyboard navigation. However, in the few cases where\n * this is not the case, we can require an explicit index from the app.\n */\n\n\nfunction useDescendant(descendant, context, indexProp) {\n  var forceUpdate = useForceUpdate();\n\n  var _React$useContext = useContext(context),\n      registerDescendant = _React$useContext.registerDescendant,\n      unregisterDescendant = _React$useContext.unregisterDescendant,\n      descendants = _React$useContext.descendants; // This will initially return -1 because we haven't registered the descendant\n  // on the first render. After we register, this will then return the correct\n  // index on the following render and we will re-register descendants\n  // so that everything is up-to-date before the user interacts with a\n  // collection.\n\n\n  var index = indexProp != null ? indexProp : descendants.findIndex(function (item) {\n    return item.element === descendant.element;\n  });\n  var previousDescendants = usePrevious(descendants); // We also need to re-register descendants any time ANY of the other\n  // descendants have changed. My brain was melting when I wrote this and it\n  // feels a little off, but checking in render and using the result in the\n  // effect's dependency array works well enough.\n\n  var someDescendantsHaveChanged = descendants.some(function (descendant, index) {\n    var _previousDescendants$;\n\n    return descendant.element !== (previousDescendants == null ? void 0 : (_previousDescendants$ = previousDescendants[index]) == null ? void 0 : _previousDescendants$.element);\n  }); // Prevent any flashing\n\n  useIsomorphicLayoutEffect(function () {\n    if (!descendant.element) forceUpdate();\n    registerDescendant(_extends({}, descendant, {\n      index: index\n    }));\n    return function () {\n      return unregisterDescendant(descendant.element);\n    }; // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [forceUpdate, index, registerDescendant, someDescendantsHaveChanged, unregisterDescendant].concat(Object.values(descendant)));\n  return index;\n}\n\nfunction useDescendantsInit() {\n  return useState([]);\n}\n\nfunction useDescendants(ctx) {\n  return useContext(ctx).descendants;\n}\n\nfunction DescendantProvider(_ref) {\n  var Ctx = _ref.context,\n      children = _ref.children,\n      items = _ref.items,\n      set = _ref.set;\n  var registerDescendant = useCallback(function (_ref2) {\n    var element = _ref2.element,\n        explicitIndex = _ref2.index,\n        rest = _objectWithoutPropertiesLoose(_ref2, [\"element\", \"index\"]);\n\n    if (!element) {\n      return;\n    }\n\n    set(function (items) {\n      var newItems;\n\n      if (explicitIndex != null) {\n        newItems = [].concat(items, [_extends({}, rest, {\n          element: element,\n          index: explicitIndex\n        })]);\n      } else if (items.length === 0) {\n        // If there are no items, register at index 0 and bail.\n        newItems = [].concat(items, [_extends({}, rest, {\n          element: element,\n          index: 0\n        })]);\n      } else if (items.find(function (item) {\n        return item.element === element;\n      })) {\n        // If the element is already registered, just use the same array\n        newItems = items;\n      } else {\n        // When registering a descendant, we need to make sure we insert in\n        // into the array in the same order that it appears in the DOM. So as\n        // new descendants are added or maybe some are removed, we always know\n        // that the array is up-to-date and correct.\n        //\n        // So here we look at our registered descendants and see if the new\n        // element we are adding appears earlier than an existing descendant's\n        // DOM node via `node.compareDocumentPosition`. If it does, we insert\n        // the new element at this index. Because `registerDescendant` will be\n        // called in an effect every time the descendants state value changes,\n        // we should be sure that this index is accurate when descendent\n        // elements come or go from our component.\n        var index = items.findIndex(function (item) {\n          if (!item.element || !element) {\n            return false;\n          } // Does this element's DOM node appear before another item in the\n          // array in our DOM tree? If so, return true to grab the index at\n          // this point in the array so we know where to insert the new\n          // element.\n\n\n          return Boolean(item.element.compareDocumentPosition(element) & Node.DOCUMENT_POSITION_PRECEDING);\n        });\n\n        var newItem = _extends({}, rest, {\n          element: element,\n          index: index\n        }); // If an index is not found we will push the element to the end.\n\n\n        if (index === -1) {\n          newItems = [].concat(items, [newItem]);\n        } else {\n          newItems = [].concat(items.slice(0, index), [newItem], items.slice(index));\n        }\n      }\n\n      return newItems.map(function (item, index) {\n        return _extends({}, item, {\n          index: index\n        });\n      });\n    });\n  }, // set is a state setter initialized by the useDescendantsInit hook.\n  // We can safely ignore the lint warning here because it will not change\n  // between renders.\n  // eslint-disable-next-line react-hooks/exhaustive-deps\n  []);\n  var unregisterDescendant = useCallback(function (element) {\n    if (!element) {\n      return;\n    }\n\n    set(function (items) {\n      return items.filter(function (item) {\n        return element !== item.element;\n      });\n    });\n  }, // set is a state setter initialized by the useDescendantsInit hook.\n  // We can safely ignore the lint warning here because it will not change\n  // between renders.\n  // eslint-disable-next-line react-hooks/exhaustive-deps\n  []);\n  return /*#__PURE__*/createElement(Ctx.Provider, {\n    value: useMemo(function () {\n      return {\n        descendants: items,\n        registerDescendant: registerDescendant,\n        unregisterDescendant: unregisterDescendant\n      };\n    }, [items, registerDescendant, unregisterDescendant])\n  }, children);\n}\n/**\n * Testing this as an abstraction for compound components that use keyboard\n * navigation. Hoping this will help us prevent bugs and mismatched behavior\n * across various components, but it may also prove to be too messy of an\n * abstraction in the end.\n *\n * Currently used in:\n *   - Tabs\n *   - Accordion\n *\n * @param context\n * @param options\n */\n\n\nfunction useDescendantKeyDown(context, options) {\n  var _React$useContext2 = useContext(context),\n      descendants = _React$useContext2.descendants;\n\n  var callback = options.callback,\n      currentIndex = options.currentIndex,\n      filter = options.filter,\n      _options$key = options.key,\n      key = _options$key === void 0 ? \"index\" : _options$key,\n      _options$orientation = options.orientation,\n      orientation = _options$orientation === void 0 ? \"vertical\" : _options$orientation,\n      _options$rotate = options.rotate,\n      rotate = _options$rotate === void 0 ? true : _options$rotate,\n      _options$rtl = options.rtl,\n      rtl = _options$rtl === void 0 ? false : _options$rtl;\n  return function handleKeyDown(event) {\n    if (![\"ArrowDown\", \"ArrowUp\", \"ArrowLeft\", \"ArrowRight\", \"PageUp\", \"PageDown\", \"Home\", \"End\"].includes(event.key)) {\n      return;\n    }\n\n    var index = currentIndex != null ? currentIndex : -1; // If we use a filter function, we need to re-index our descendants array\n    // so that filtered descendent elements aren't selected.\n\n    var selectableDescendants = filter ? descendants.filter(filter) : descendants; // Current index should map to the updated array vs. the original\n    // descendants array.\n\n    if (filter) {\n      index = selectableDescendants.findIndex(function (descendant) {\n        return descendant.index === currentIndex;\n      });\n    } // We need some options for any of this to work!\n\n\n    if (!selectableDescendants.length) {\n      return;\n    }\n\n    function getNextOption() {\n      var atBottom = index === selectableDescendants.length - 1;\n      return atBottom ? rotate ? getFirstOption() : selectableDescendants[index] : selectableDescendants[(index + 1) % selectableDescendants.length];\n    }\n\n    function getPreviousOption() {\n      var atTop = index === 0;\n      return atTop ? rotate ? getLastOption() : selectableDescendants[index] : selectableDescendants[(index - 1 + selectableDescendants.length) % selectableDescendants.length];\n    }\n\n    function getFirstOption() {\n      return selectableDescendants[0];\n    }\n\n    function getLastOption() {\n      return selectableDescendants[selectableDescendants.length - 1];\n    }\n\n    switch (event.key) {\n      case \"ArrowDown\":\n        if (orientation === \"vertical\" || orientation === \"both\") {\n          event.preventDefault();\n          var next = getNextOption();\n          callback(key === \"option\" ? next : next[key]);\n        }\n\n        break;\n\n      case \"ArrowUp\":\n        if (orientation === \"vertical\" || orientation === \"both\") {\n          event.preventDefault();\n          var prev = getPreviousOption();\n          callback(key === \"option\" ? prev : prev[key]);\n        }\n\n        break;\n\n      case \"ArrowLeft\":\n        if (orientation === \"horizontal\" || orientation === \"both\") {\n          event.preventDefault();\n          var nextOrPrev = (rtl ? getNextOption : getPreviousOption)();\n          callback(key === \"option\" ? nextOrPrev : nextOrPrev[key]);\n        }\n\n        break;\n\n      case \"ArrowRight\":\n        if (orientation === \"horizontal\" || orientation === \"both\") {\n          event.preventDefault();\n          var prevOrNext = (rtl ? getPreviousOption : getNextOption)();\n          callback(key === \"option\" ? prevOrNext : prevOrNext[key]);\n        }\n\n        break;\n\n      case \"PageUp\":\n        event.preventDefault();\n        var prevOrFirst = (event.ctrlKey ? getPreviousOption : getFirstOption)();\n        callback(key === \"option\" ? prevOrFirst : prevOrFirst[key]);\n        break;\n\n      case \"Home\":\n        event.preventDefault();\n        var first = getFirstOption();\n        callback(key === \"option\" ? first : first[key]);\n        break;\n\n      case \"PageDown\":\n        event.preventDefault();\n        var nextOrLast = (event.ctrlKey ? getNextOption : getLastOption)();\n        callback(key === \"option\" ? nextOrLast : nextOrLast[key]);\n        break;\n\n      case \"End\":\n        event.preventDefault();\n        var last = getLastOption();\n        callback(key === \"option\" ? last : last[key]);\n        break;\n    }\n  };\n} ////////////////////////////////////////////////////////////////////////////////\n\n\nexport { DescendantProvider, createDescendantContext, useDescendant, useDescendantKeyDown, useDescendants, useDescendantsInit };","map":{"version":3,"sources":["/Users/ielouazz/Desktop/Matchaa/client/node_modules/@reach/descendants/dist/reach-descendants.esm.js"],"names":["useContext","useState","useCallback","createElement","useMemo","useForceUpdate","useIsomorphicLayoutEffect","usePrevious","createNamedContext","noop","_objectWithoutPropertiesLoose","source","excluded","target","sourceKeys","Object","keys","key","i","length","indexOf","_extends","assign","arguments","prototype","hasOwnProperty","call","apply","createDescendantContext","name","initialValue","descendants","registerDescendant","unregisterDescendant","useDescendant","descendant","context","indexProp","forceUpdate","_React$useContext","index","findIndex","item","element","previousDescendants","someDescendantsHaveChanged","some","_previousDescendants$","concat","values","useDescendantsInit","useDescendants","ctx","DescendantProvider","_ref","Ctx","children","items","set","_ref2","explicitIndex","rest","newItems","find","Boolean","compareDocumentPosition","Node","DOCUMENT_POSITION_PRECEDING","newItem","slice","map","filter","Provider","value","useDescendantKeyDown","options","_React$useContext2","callback","currentIndex","_options$key","_options$orientation","orientation","_options$rotate","rotate","_options$rtl","rtl","handleKeyDown","event","includes","selectableDescendants","getNextOption","atBottom","getFirstOption","getPreviousOption","atTop","getLastOption","preventDefault","next","prev","nextOrPrev","prevOrNext","prevOrFirst","ctrlKey","first","nextOrLast","last"],"mappings":"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","sourcesContent":["import { useContext, useState, useCallback, createElement, useMemo } from 'react';\nimport { useForceUpdate } from '@reach/utils/use-force-update';\nimport { useIsomorphicLayoutEffect } from '@reach/utils/use-isomorphic-layout-effect';\nimport { usePrevious } from '@reach/utils/use-previous';\nimport { createNamedContext } from '@reach/utils/context';\nimport { noop } from '@reach/utils/noop';\n\nfunction _objectWithoutPropertiesLoose(source, excluded) {\n  if (source == null) return {};\n  var target = {};\n  var sourceKeys = Object.keys(source);\n  var key, i;\n\n  for (i = 0; i < sourceKeys.length; i++) {\n    key = sourceKeys[i];\n    if (excluded.indexOf(key) >= 0) continue;\n    target[key] = source[key];\n  }\n\n  return target;\n}\n\nfunction _extends() {\n  _extends = Object.assign || function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n\n    return target;\n  };\n\n  return _extends.apply(this, arguments);\n}\n\nfunction createDescendantContext(name, initialValue) {\n  if (initialValue === void 0) {\n    initialValue = {};\n  }\n\n  var descendants = [];\n  return createNamedContext(name, _extends({\n    descendants: descendants,\n    registerDescendant: noop,\n    unregisterDescendant: noop\n  }, initialValue));\n}\n/**\n * This hook registers our descendant by passing it into an array. We can then\n * search that array by to find its index when registering it in the component.\n * We use this for focus management, keyboard navigation, and typeahead\n * functionality for some components.\n *\n * The hook accepts the element node and (optionally) a key. The key is useful\n * if multiple descendants have identical text values and we need to\n * differentiate siblings for some reason.\n *\n * Our main goals with this are:\n *   1) maximum composability,\n *   2) minimal API friction\n *   3) SSR compatibility*\n *   4) concurrent safe\n *   5) index always up-to-date with the tree despite changes\n *   6) works with memoization of any component in the tree (hopefully)\n *\n * * As for SSR, the good news is that we don't actually need the index on the\n * server for most use-cases, as we are only using it to determine the order of\n * composed descendants for keyboard navigation. However, in the few cases where\n * this is not the case, we can require an explicit index from the app.\n */\n\n\nfunction useDescendant(descendant, context, indexProp) {\n  var forceUpdate = useForceUpdate();\n\n  var _React$useContext = useContext(context),\n      registerDescendant = _React$useContext.registerDescendant,\n      unregisterDescendant = _React$useContext.unregisterDescendant,\n      descendants = _React$useContext.descendants; // This will initially return -1 because we haven't registered the descendant\n  // on the first render. After we register, this will then return the correct\n  // index on the following render and we will re-register descendants\n  // so that everything is up-to-date before the user interacts with a\n  // collection.\n\n\n  var index = indexProp != null ? indexProp : descendants.findIndex(function (item) {\n    return item.element === descendant.element;\n  });\n  var previousDescendants = usePrevious(descendants); // We also need to re-register descendants any time ANY of the other\n  // descendants have changed. My brain was melting when I wrote this and it\n  // feels a little off, but checking in render and using the result in the\n  // effect's dependency array works well enough.\n\n  var someDescendantsHaveChanged = descendants.some(function (descendant, index) {\n    var _previousDescendants$;\n\n    return descendant.element !== (previousDescendants == null ? void 0 : (_previousDescendants$ = previousDescendants[index]) == null ? void 0 : _previousDescendants$.element);\n  }); // Prevent any flashing\n\n  useIsomorphicLayoutEffect(function () {\n    if (!descendant.element) forceUpdate();\n    registerDescendant(_extends({}, descendant, {\n      index: index\n    }));\n    return function () {\n      return unregisterDescendant(descendant.element);\n    }; // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [forceUpdate, index, registerDescendant, someDescendantsHaveChanged, unregisterDescendant].concat(Object.values(descendant)));\n  return index;\n}\n\nfunction useDescendantsInit() {\n  return useState([]);\n}\n\nfunction useDescendants(ctx) {\n  return useContext(ctx).descendants;\n}\n\nfunction DescendantProvider(_ref) {\n  var Ctx = _ref.context,\n      children = _ref.children,\n      items = _ref.items,\n      set = _ref.set;\n  var registerDescendant = useCallback(function (_ref2) {\n    var element = _ref2.element,\n        explicitIndex = _ref2.index,\n        rest = _objectWithoutPropertiesLoose(_ref2, [\"element\", \"index\"]);\n\n    if (!element) {\n      return;\n    }\n\n    set(function (items) {\n      var newItems;\n\n      if (explicitIndex != null) {\n        newItems = [].concat(items, [_extends({}, rest, {\n          element: element,\n          index: explicitIndex\n        })]);\n      } else if (items.length === 0) {\n        // If there are no items, register at index 0 and bail.\n        newItems = [].concat(items, [_extends({}, rest, {\n          element: element,\n          index: 0\n        })]);\n      } else if (items.find(function (item) {\n        return item.element === element;\n      })) {\n        // If the element is already registered, just use the same array\n        newItems = items;\n      } else {\n        // When registering a descendant, we need to make sure we insert in\n        // into the array in the same order that it appears in the DOM. So as\n        // new descendants are added or maybe some are removed, we always know\n        // that the array is up-to-date and correct.\n        //\n        // So here we look at our registered descendants and see if the new\n        // element we are adding appears earlier than an existing descendant's\n        // DOM node via `node.compareDocumentPosition`. If it does, we insert\n        // the new element at this index. Because `registerDescendant` will be\n        // called in an effect every time the descendants state value changes,\n        // we should be sure that this index is accurate when descendent\n        // elements come or go from our component.\n        var index = items.findIndex(function (item) {\n          if (!item.element || !element) {\n            return false;\n          } // Does this element's DOM node appear before another item in the\n          // array in our DOM tree? If so, return true to grab the index at\n          // this point in the array so we know where to insert the new\n          // element.\n\n\n          return Boolean(item.element.compareDocumentPosition(element) & Node.DOCUMENT_POSITION_PRECEDING);\n        });\n\n        var newItem = _extends({}, rest, {\n          element: element,\n          index: index\n        }); // If an index is not found we will push the element to the end.\n\n\n        if (index === -1) {\n          newItems = [].concat(items, [newItem]);\n        } else {\n          newItems = [].concat(items.slice(0, index), [newItem], items.slice(index));\n        }\n      }\n\n      return newItems.map(function (item, index) {\n        return _extends({}, item, {\n          index: index\n        });\n      });\n    });\n  }, // set is a state setter initialized by the useDescendantsInit hook.\n  // We can safely ignore the lint warning here because it will not change\n  // between renders.\n  // eslint-disable-next-line react-hooks/exhaustive-deps\n  []);\n  var unregisterDescendant = useCallback(function (element) {\n    if (!element) {\n      return;\n    }\n\n    set(function (items) {\n      return items.filter(function (item) {\n        return element !== item.element;\n      });\n    });\n  }, // set is a state setter initialized by the useDescendantsInit hook.\n  // We can safely ignore the lint warning here because it will not change\n  // between renders.\n  // eslint-disable-next-line react-hooks/exhaustive-deps\n  []);\n  return /*#__PURE__*/createElement(Ctx.Provider, {\n    value: useMemo(function () {\n      return {\n        descendants: items,\n        registerDescendant: registerDescendant,\n        unregisterDescendant: unregisterDescendant\n      };\n    }, [items, registerDescendant, unregisterDescendant])\n  }, children);\n}\n/**\n * Testing this as an abstraction for compound components that use keyboard\n * navigation. Hoping this will help us prevent bugs and mismatched behavior\n * across various components, but it may also prove to be too messy of an\n * abstraction in the end.\n *\n * Currently used in:\n *   - Tabs\n *   - Accordion\n *\n * @param context\n * @param options\n */\n\n\nfunction useDescendantKeyDown(context, options) {\n  var _React$useContext2 = useContext(context),\n      descendants = _React$useContext2.descendants;\n\n  var callback = options.callback,\n      currentIndex = options.currentIndex,\n      filter = options.filter,\n      _options$key = options.key,\n      key = _options$key === void 0 ? \"index\" : _options$key,\n      _options$orientation = options.orientation,\n      orientation = _options$orientation === void 0 ? \"vertical\" : _options$orientation,\n      _options$rotate = options.rotate,\n      rotate = _options$rotate === void 0 ? true : _options$rotate,\n      _options$rtl = options.rtl,\n      rtl = _options$rtl === void 0 ? false : _options$rtl;\n  return function handleKeyDown(event) {\n    if (![\"ArrowDown\", \"ArrowUp\", \"ArrowLeft\", \"ArrowRight\", \"PageUp\", \"PageDown\", \"Home\", \"End\"].includes(event.key)) {\n      return;\n    }\n\n    var index = currentIndex != null ? currentIndex : -1; // If we use a filter function, we need to re-index our descendants array\n    // so that filtered descendent elements aren't selected.\n\n    var selectableDescendants = filter ? descendants.filter(filter) : descendants; // Current index should map to the updated array vs. the original\n    // descendants array.\n\n    if (filter) {\n      index = selectableDescendants.findIndex(function (descendant) {\n        return descendant.index === currentIndex;\n      });\n    } // We need some options for any of this to work!\n\n\n    if (!selectableDescendants.length) {\n      return;\n    }\n\n    function getNextOption() {\n      var atBottom = index === selectableDescendants.length - 1;\n      return atBottom ? rotate ? getFirstOption() : selectableDescendants[index] : selectableDescendants[(index + 1) % selectableDescendants.length];\n    }\n\n    function getPreviousOption() {\n      var atTop = index === 0;\n      return atTop ? rotate ? getLastOption() : selectableDescendants[index] : selectableDescendants[(index - 1 + selectableDescendants.length) % selectableDescendants.length];\n    }\n\n    function getFirstOption() {\n      return selectableDescendants[0];\n    }\n\n    function getLastOption() {\n      return selectableDescendants[selectableDescendants.length - 1];\n    }\n\n    switch (event.key) {\n      case \"ArrowDown\":\n        if (orientation === \"vertical\" || orientation === \"both\") {\n          event.preventDefault();\n          var next = getNextOption();\n          callback(key === \"option\" ? next : next[key]);\n        }\n\n        break;\n\n      case \"ArrowUp\":\n        if (orientation === \"vertical\" || orientation === \"both\") {\n          event.preventDefault();\n          var prev = getPreviousOption();\n          callback(key === \"option\" ? prev : prev[key]);\n        }\n\n        break;\n\n      case \"ArrowLeft\":\n        if (orientation === \"horizontal\" || orientation === \"both\") {\n          event.preventDefault();\n          var nextOrPrev = (rtl ? getNextOption : getPreviousOption)();\n          callback(key === \"option\" ? nextOrPrev : nextOrPrev[key]);\n        }\n\n        break;\n\n      case \"ArrowRight\":\n        if (orientation === \"horizontal\" || orientation === \"both\") {\n          event.preventDefault();\n          var prevOrNext = (rtl ? getPreviousOption : getNextOption)();\n          callback(key === \"option\" ? prevOrNext : prevOrNext[key]);\n        }\n\n        break;\n\n      case \"PageUp\":\n        event.preventDefault();\n        var prevOrFirst = (event.ctrlKey ? getPreviousOption : getFirstOption)();\n        callback(key === \"option\" ? prevOrFirst : prevOrFirst[key]);\n        break;\n\n      case \"Home\":\n        event.preventDefault();\n        var first = getFirstOption();\n        callback(key === \"option\" ? first : first[key]);\n        break;\n\n      case \"PageDown\":\n        event.preventDefault();\n        var nextOrLast = (event.ctrlKey ? getNextOption : getLastOption)();\n        callback(key === \"option\" ? nextOrLast : nextOrLast[key]);\n        break;\n\n      case \"End\":\n        event.preventDefault();\n        var last = getLastOption();\n        callback(key === \"option\" ? last : last[key]);\n        break;\n    }\n  };\n} ////////////////////////////////////////////////////////////////////////////////\n\nexport { DescendantProvider, createDescendantContext, useDescendant, useDescendantKeyDown, useDescendants, useDescendantsInit };\n"]},"metadata":{},"sourceType":"module"}